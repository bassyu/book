# 데이터 타입

기본형 타입과 참조형 타입이 서로 다르게 동작하는 이유를 이해하고
이를 적절히 활용하자

## 데이터 타입의 종류

기본형(primitive type)과 참조형(reference type)이 있다.

- 기본형

  - Number
  - String
  - Boolean
  - null
  - undefined
  - Symbol

- 참조형
  - Object
    - Array
    - Function
    - Date
    - RegExp
    - Map, WeakMap
    - Set, WeakSet

어떤 기준으로 구분하는가?

기본형은 값이 담긴 주솟값을 바로 복제한다. <br />
참조형은 값이 담긴 주솟값들로 이루어진 묶음을 가리키는 주솟값을 복제한다.

(C언어의 포인터 느낌과 비슷하다)

## 데이터 타입에 관한 배경지식

### 메모리와 데이터

메모리는 2가지 상태를 저장할 수 있는 bit로만 구성되어 있다.
모든 bit에 주소를 붙이고 관리하자니 너무 비효율적이다. <br />
그래서 byte 라는 단위 등장

C언어는 데이터 타입을 선택할 수 있다. (char === 1byte, long int === 4byte)

반면 JS는 숫자면 다 8byte이다.

### 식별자와 변수

변수(variable)와 식별자(identifier)를 혼용하는 경우가 많다.

변수 === 변할 수 있는 무언가 === 데이터
식별자 === 데이터를 식별하는 이름 === 변수명

## 변수 선언과 데이터 할당

### 변수 선언

변수를 선언하면 메모리에 **식별자**(변수의 이름)와 **주소**를 담을 수 있는 공간이 마련됨

### 데이터 할당

변수에 데이터를 할당하면 값이 바로 들어가는 게 아니다.

1. 데이터 영역의 빈 공간에 값이 들어간다.
2. 변수 영역에서 해당 데이터 영역의 주소를 저장한다.

왜 이렇게 할까?

JS에서 변수 안의 데이터는 (C언어와는 다르게)가변적이다. (특히 문자열)

효율적으로 문자열 데이터의 변환을 처리하려면 변수와 데이터를 별도의 공간에 나누어 저장하는 것이 최적이다.

'abc'에 'def'를 추가하라고 하면 원래 데이터를 수정하는 것이 아니라<br />
'abcdef'라는 문자열을 새로 만들어서 그 데이터 영역 주소에 연결합니다. 다른 상황도 마찬가지 이다.

또한 여러 변수의 데이터가 같다면 데이터 주소에 연결만 하면 돼서 효율적이다.

## 기본형 데이터와 참조형 데이터

### 불변값

기본형 데이터인 숫자, 문자열, boolean, null, undefined, Symbol은 모두 불변값이다.

예를들면 a += 1 을 해도 데이터 영역의 1을 수정하는 것이 아니라 2를 새로 만들고 주소만 바꾼다.

**불변값, 기본형은 가비지 컬렉팅을 당하지 않는 한 절대 바뀌지 않는다.**

### 가변값

참조형은 거의 그렇지만 전부 가변값은 아니다. (Object.freeze 등)

참조형이 가리키는 데이터 영역 안엔 **(자신의)변수 영역 주소**가 들어있다.

'변수 영역 주소'안의 변수들이 다시 데이터 영역의 주소를 가리킨다.

그리고 '변수 영역 주소'안의 변수들이 바뀔 때 '가변했다'라고 할 수 있다. <br />
(결국 참조형이 가리키는 데이터 영역 주소는 바뀌지 않았다)

### 가비지 컬렉터

자신의 주소를 참조하는 변수의 개수를 참조 카운트라고 한다.

참조 카운트가 0이 된 메모리 주소들은 가비지 컬렉터의 수거 대상이 된다.

가비지 컬렉터는 런타임 환경에 따라 **특정 시점이나 메모리 사용량이 포화에 임박할 때** 수거 대상들을 수거한다.

### 변수 복사 비교

사실 변수 복사는 기본형 변수와 참조형 변수의 차이가 없다.

많은 곳에서 '기본형은 값을 복사하고 참조형은 주소를 복사한다'고 설명하지만, 정확히는 둘 다 **데이터 영역의 주소**를 복사한다.

다만 그 데이터 영역 안에 값이 있는지, 또다른 주소가 있는지의 차이이다.

## 불변 객체

### 불변 객체를 만드는 간단한 방법

복사한 객체에 변경을 가하더라도 원본 객체는 변하지 않아야 하는 경우가 종종 발생한다.

이때 불변 객체가 필요하다.

### 얕은 복사와 깊은 복사

얕은 복사는 바로 아래 단계의 값만 복사하는 방법이고, 깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법이다.

여기서 복사란 '변수 영역에 같은 데이터 영역을 가리키는 주소 새로 할당' 즉, 같은 값을 가지는 새로운 변수를 의미한다.

### 간단하게 깊은 복사를 처리할 수 있는 방법

객체를 JSON 문법으로 표현된 문자열로 전환했다가 다시 JSON 객체로 바꾸면 된다.

다만 메서드, 숨겨진 프로퍼티, getter/setter 등은 무시하니 response로 받은 순수한 정보만 다룰 때 활용하자.

## undefined와 null

둘다 없을을 나타내지만 사용하는 목적이 다르다.

undefined는 아래같은 상황일 때 JS엔진이 자동으로 부여할 수 있다.

1. 데이터 영역의 메모리 주소를 지정하지 않은 식별자에 접근할 때
2. 객체 내부의 존재하지 않는 프로퍼티에 접근하려고 할 때
3. return 문이 없거나 호출되지 않는 함수의 실행 결과

근데 또 배열에서는 `undefined`라도 있으면 순회는 하지만 `empty`는 순회도 안한다.

```javascript
const arr = [];
arr[1] = "value";
// arr -> [empty, "value"]

arr.forEach((v) => {
  console.log(v);
});
// value

arr.map((v) => v);
// [empty, "value"]

arr.filter((v) => !v);
// []

arr.reduce((acc, cur) => acc + cur, "");
// "value"
```

결국

1. 명시적으로 부여한 undefined
2. 엔진이 뱉어주는 undefined
3. 명시적으로 부여한 null

은 모두 다른 것이다.

**따라서 undefined를 명시적으로 부여하는 것은 지양하는 것이 좋겠다.**

### var / let, const

environmentRecord가 인스턴스화될 때

- var 변수는 undefined를 직접 할당, 접근 가능
- let, const는 변수만 할당, 변수가 평가되기 전까지는 접근 불가

## 정리

- 데이터는 기본형이거나 참조형임
- 기본형은 모두 불변값이고 참조형은 보통 가변값임
- 변수는 공간, 식별자는 이름
- 참조형의 데이터는 변수를 모은 그룹(주소)이고, 그 안의 변수의 값은 변하기 때문에 가변값으로 여김
- 그러나 불변값으로 사용하려면 일일이 복사하거나 라이브러리를 사용하면 됨
- 명시적으로 undefined를 대입하는 것은 지양하자
